Comandos de interés con git:

    - "ls": para ver los diferentes archivos y folders que hay en la ruta actual
    - "ls -a": nos permite ver el también los archivos o folders ocultos, por lo que si apuntamos a un folder con repositorio, aparecerá la carpeta "git"
    - "pwd": nos indica la ruta actual en la que nos encontramos
    - "cd <nombre_directorio>": nos ayuda a apuntar a un directorio contenido en la ruta actual que tenemos
    - "cd ..": nos hace ir hacia atrás (aumentar el nivel de jerarquía), es decir, nos hace apuntar al directorio superior que contiene el directorio al que apuntamos
    - "mkdir <nomobre_nuevo_directorio>": nos ayuda a crear un directorio en la ruta actual en la que estamos
    - "rm <nombre_archivo>": se utiliza para eliminar el archivo o folder indicando su nombre
    - "git rm <nombre_del_archivo>": elimina el archivo o folder indicado y además pasa estos cambios crudos al estado de stage
    - "git restore --staged <nombre_del_archivo>: este comando permite sacar los cambios de un archivo o folder de la etapa de stage y devolverlos a la etapa de cambios crudos
    - "git restore <nombre_del_archivo": este comando permite eliminar el cambio crudo, es decir, si teníamos una versión limpia y realizamos cambios crudos, nos los elimina
    - "git add <nombre_archivo": para pasar los cambios referidos a ese archivo de estado crudo a stage [si en vez del nombre ponemos <*.txt>, añadirá los cambios que tengan esta extensión; usamos <.> para pasar todos los crudos a estado de Stage]
    - "git commit -m "<Nombre_del_commit>": pasamos los cambios del estado stage a estado commit, he indicamos el nombre que hace referencia a todo ese conjunto de cambios
    - "mv <nombre_archivo_a_cambiar_de_nombre> <nuevo_nombre>": sirve para cambiar el nombre de un archivo o folder (*1)
    - "git mv <nombre_archivo_a_cambiar_de_nombre> <nuevo_nombre>": es la versión de git de mv que realiza los stages automáticos de los dos cambios (*1)
    - "git diff": nos permite ver los cambios que tenemos pendientes de pasar a stage. Estos cambios no solo hacen referencia a los archivos con cambios, si no que, 
    muestran directamente los cambios que hay en dichos archivos.
    - "git diff --staged": esto es lo mismo, pero nos saldrán los cambios que ya están en la etapa de stage
    - "git log": nos enseña el historico de commits de la rama a la que apuntamos
    - "git log --oneline": es lo mismo, pero es un resumen más escueto y más ordenado de la versión simple
    - "git branch": nos muesta las ramas contenidas y abiertas en nuestro repositorio, así como la rama actual en la que estamos trabajando
    - "git checkout -b <nombre_de_la_rama_a_crear>": nos ayuda a crear una rama nueva y automáticamente nos desplazamos a dicha rama que creamos
    - "git merge <nombre_de_la_rama_a_traer>: este comando traer los cambios relativos a la rama indicada con respecto a la rama a la cual apuntamos en ese momento,
    a esta misma rama, es decir, si estamos en "main" y existen diferencias de esta con respecto a la rama "rama2", y queremos traer estos cambios (diff), haremos
    git merge rama2 (mientras que nuestra rama actual sea main), esto aplicará las diferencias a nuestra rama "main" y no haría falta pasarlos a "stage", o commitearlos, 
    ya estos cambios se suben automáticamente al repo.
    - "git remote add origin <direccion_http_repositorio>": esta sería una manera haber creado un repositorio en GitHub y hacer un linkado entre nuestro repositorio local
    y el repositorio que tenemos en GitHub. Entiendo que este repositorio debería de estar vacío para poder hacer el linkado.
    - "git push -u origin <nombre_de_la_rama_a_subir>": para evitar sopresas, lo suyo sería escribir el nombre de la rama en la cual estamos en ese momento. El símbolo "-u" 
    lo que indica es que, conociendo que esa rama no existe en el repositorio remoto, la creará y alojará nuestro push en ella.
    - "git fetch": sirve para traer información actualizada del repositorio remoto, lo cual nos ayuda a conocer las distintas ramas que hay, los últimos commits...
    - "git pull <nombre_del_remoto> <nombre_de_la_rama_de_remoto_a_traer>": si tenemos la misma rama en local, pero está atrasada en commits, pues hay dos opciones, que no 
    tengamos en local nuevos cambios, lo cual lo que nos hace es un merge sin conflictos y que no deja huella, es decir, simplemente actualiza nuestra rama local al último 
    commit remoto, mientras que si tenemos cambios, hará un merge que puede que tenga conflictos o no, pero si dejará huella de que se ha realizado un merge en el histórico
    del "log". En caso de haber conflictos será el visual studio el que nos ayude a resolverlos.


Conceptos a tener en cuenta:

    - Estados de los cambios: cambios son toda aquella información nueva, desde nuevos caracteres como eliminación de los mismos. Estos cambios solo pueden estar en
    en un estado al mismo tiempo.
        *Estado crudo: son camios recién hechos, toda información nueva que borremos o eliminemos, en ese mismo instante estarán en estado de crudo
        *Estado stage: en este estado, solo dejaremos que lo adquieran los cambios que queremos que aparezcan en nuestro repositorio, es decir, queremos conservarlos o guardarlos
        *Estado commit: son ya cambios comprometido en el sentido que dejamos constancia en nuestro ordenador local de su presencia y por ende, van a quedar registrados
        mientras exista el repositorio.
        *Estado server: esto ocurre de la misma manera, pero estos cambios quedan registrados en un servidor y son accesibles de manera remota, por uno o varios usuarios.

    - (*1) Los cambios en git van referenciados a nombres, es decir, cuando creamos un archivo, todo los cambios que hagamos en él, serán referenciados a ese mismo archivo con su nombre, 
    en caso de cambiar su nombre, git interpretará que el archivo fue eliminado y que se ha creado otro de la nada, osea, se consideran dos cambios.

    -".gitignore": es un archivo usuado para definir los archivos y folders que no se desean ser rastreados por git, es decir, si hay un cambio crudo en estos, git no nos indicará que 
    hay cambios por pasar a stage, simplemente, no los detecta, y aunque hagamos un "git add .", se añadirán los cambios a stage que git ve, pero los archivos y folders designados en 
    .gitignore no se "stagearán". Esta herramienta es un archivo de texto, en el cual definimos los folders y archivos a ignorar, incluso podemos definir todos los archivos que tengan
    una extensión en concreto. La propia creación de este archivo si es visible para git, por lo que la creación y cambios en este si son cambios trackeables. Estos archivos
    ocultos son ocultos solo para git, en el caso de realizar un "ls", pues aparecerán los archivos que son ocultos para git también.

    - El main local es local a secas, y tiene información referida a su situación actual local, pero si tratamos con  "origin main" estaríamos hablando de las últimas condiciones del 
    main remoto que conocemos localmente, estén presentes o no en mi repositorio local.

    -Primera aplicación de los stashes. No entiendo por que no se registran cambios.

    - Hola cambio.
    

